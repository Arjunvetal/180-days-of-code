=> AntiforgeryToken()
- check iof the code is not generated by the bots
- servers the security purpose


=======================

@using(@Html.BeginForm())
{
	----- html form
}

----------------------------------------


@Html.ActionLink("name","action",new{id=item.EmpNo, param1 = item.Name})

----------------------------------------

Repeatative code is kept in diff layer

BOL - DAL - DB
Business Object Layer
Data Access Layer
Data base

----------------------------------------
Imp difference :

@Html.Display(); -- loosely bound
@Html.DisplayFor(model=>model.EmpNo); -- tighly bound with the model

------- TextBox 

@Html.TextBox("nameIstxt1","valueIshello");


Below two textBoxes are the same and model binded!

@Html.TextBox("Name",Model.Name);


@Html.TextBoxFor(x=>x.Name)

-- name for the above input field would be EmpNo which is pickedUp from the model
hence its tightly coupled view!


------- check Box

@Html.CheckBox("chk1");

@Html.checkBoxFor(model=>mode.IsActive);


------ Radio Buttons 

@Html.RadioButton("btn1",Yes); 
@Html.RadioButton("btn1",No); 
@Html.RadioButton("btn1",May be); 

--------- DropDown List

@Html.DropDownList("ddlDepts", Model.Departments);


@Html.DropDownListFor(model=> model.DeptNo, Model.Departments)


@Html.DropDownListFor(model=> model.DeptNo, (Ienumerable<ListSelectItem>)ViewBag.Departments)


- Model is something created based on system design, requirements!
that mirror the real world!

- View Model is the class that is required by the view! View can be shown properly!

eg.
- Employee class with the listOfDepartments!

Ienumerable<SelectListItem> var{se;lget;};



Model Binding : Input in the view have the same name as that oif the properties of the Model!


----------------------------------------
=> Annotations and Validations!


Required - RequiredAttribute => ValidationAttribute => Attribute


[Display(Name="Basic Salary")]


=======================

=> Partial View

If each view has the header and footer then it can be kept under the shared view in layouts!

What if the view has the same design but the postiion is diff in each view!

for that we need partial view!

select create partial view while creating new view!


-- to add in nomal view

@{

Html.RenderPartial("PartialViewName");

}

@Html.Partial("PartialViewName");


[ChildActionOnly]
used to make it not called direclty and can be called only from the views!


Why Http is stateless!
-> Data from the prev req is not available on new req!

- if it stored the data or the state then with the each req tthe laon on server will rise and scalability will be affected!
----------------------------------------
state management :

1.} ViewBag : 
- values in viewbag can be access from veiw to layout and from action to view

- values of viewBag are lost if views are returned or sendRedirect!


ViewBag.message ="aaa";
@ViewBag["message"]


So every view and viewbag has their won values!

ViewBag internally usea ViewData, and its a wrapper class for ViewData!
----------------------------------------
2.} ViewData["message"] ="aaa";

@ViewData["message"].ToString();


While retireving the data we need to type cast it in case of @ViewData!

ViewData.["i"] =1000;
int i = (int)ViewData.["i"]

ViewData.["key"] =emp;
Employee emp = (Employee)ViewData.["key"]

- ViewData is used for passing value from Controller to View
- ViewData is available only for current req.
-value is Lost on a req redirect!
- while retriving the value we must type cast it!

- is a dictionary object where key are string and values will be objects!

- derived from ViewDataDictionary Class
----------------------------------------

3} .Temp Data :

- Derived from TempDataDictionary class!
- is a dictionary object where key are string and values will be objects!

- ViewData is available only for current req.
-value is NOT lost on a req redirect!

and its true for as many redirect as possible!

from v1 to v2 to v3 and vn!


----------------------------------------
What is the session?
- time interval!

Session ends  : Session.Abandon

1.when the no req rcvd by the server from client within session time i.e after time out!

2.We can set that time also we can manually exist from the session!

3.When Application ends : when server is closed!

with req session ID is created and sent back on the client using session Cookie!

----------------------------------------
4 } Session Variables :

Session["key"] = value;


Session["i"] = 100;
int i =(int)Session["i"];


Session.Abandon
----------------------------------------
5 } QueryString : 
- 

----------------------------------------

6}Coockie :

- To enhance the user experience 
- details stored in the text file on client!
- can be given expiry date 
- We can read coockie with request and write cookies with the response


HttpCookie objCookie = new HttpCookie("ChocoChips");


objCoockie.Expire = DateTime.Now.AddDays(1);

-- storing one value
objCoockie.Value = "a";


-- storing multiple values
objCoockie.Values["Key1"] ="a";
objCoockie.Values["Key2"] ="b";

Response.Cookies.Add(objCoockie);


HttpCookie obj = Request.Cookies("chocoChips");

if its null which means wither its not created or got expired!


=> delete the cookie!


----------------------------------------
7}Application variables :

Available across all sessions! for all user logged in!

System.Web.HttpContext.Current.Application["Key"]="value";



=======================

=> Entity FrameWork :

- ORM
- Tables will be automatically created based on the classes!
 Columns will be mapped to the Properties!

- Three approaches :
DB First -DB Admin
Code First  - Sys Architech
Model First - 







----------------------------------------



----------------------------------------
----------------------------------------
